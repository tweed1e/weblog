---
title: "Why bother with covariates in A/B testing?"
author: "Jesse Tweedle"
date: '2018-02-19'
slug: why-bother-with-covariates-in-ab-testing
categories: ["r", "stats", "rstats"]
tags: ["r", "stats", "rstats", "A/B testing", "experiments", "econometrics", "CUPED"]
description: ''
image: "https://jesse.tw/images/circle-arrows.png"
---



<div id="motivation" class="section level2">
<h2>Motivation</h2>
<p>I’ll skip the part where I tell you why A/B testing is important. Just look at any data science team in tech, <a href="https://hbr.org/2017/09/the-surprising-power-of-online-experiments">Microsoft</a>, <a href="https://medium.com/airbnb-engineering/experiments-at-airbnb-e2db3abf39e7">Airbnb</a>, <a href="https://blog.twitter.com/engineering/en_us/a/2016/implications-of-use-of-multiple-controls-in-an-ab-test.html">Twitter</a>, <a href="https://www.facebook.com/notes/facebook-data-science/big-experiments-big-datas-friend-for-making-decisions/10152160441298859/">Facebook</a>, etc. etc.</p>
<p>And I’m starting to see this statement often:</p>
<blockquote>
<p>The variance that pre-experiment data can explain in a metric is unrelated to any effects of the experiment and can, therefore, be removed. (<a href="https://booking.ai/how-booking-com-increases-the-power-of-online-experiments-with-cuped-995d186fff1d">Source: CUPED</a>.)</p>
</blockquote>
<p>Economists spend their lives trying to get observational data to behave like they randomly assigned treatments. Usually that involves adding covariates until you get an answer you like, or using increasingly complicated methods (OLS, difference-in-difference, fixed effects, IVs, regression discontinuities, dynamic panels, synthetic controls, a million different standard error estimators, and so on). <em>But A/B testing starts with random assignment! The hard work is already done!</em> But I guess data science has slightly different issues, so let’s take a look.</p>
<p>The first thing economists learn is that you can drop any covariate that is uncorrelated with <strong>either</strong> the treatment variable <strong>or</strong> the outcome variable and still get a <a href="https://en.wikipedia.org/wiki/Consistent_estimator"><em>consistent</em> estimate</a> of the treatment effect. But if you like, you can include a covariate that’s uncorrelated with the treatment but correlated with the outcome to reduce the coefficient’s standard error by reducing the estimate of the standard error of the residuals (the other part of the coefficient’s standard error shouldn’t be affected in large samples because the treatment and covariates are uncorrelated). So the CUPED strategy seems pretty obvious to an economist, but I need the practice so I thought I’d look at it anyway. Does it really work that well? Why?</p>
<p>[Whoops! The answer really is that it reduces variance in the outcomes, the other stuff I find is really just confusing marginal and conditional effects. At first I thought was the point, the econometrician doesn’t know the true model, so doesn’t know to compare the conditional and marginal effects, but I was wrong. Anyway, wait for another post on that!]</p>
</div>
<div id="r-setup-and-data" class="section level2">
<h2>R setup and data</h2>
<p>Let’s get’s R started and make up a dataset.</p>
<pre class="r"><code>library(tidyverse)
library(broom)
library(viridis)

# A function that creates a tibble of fake data, 
# depending on the parameters you put in
create_data &lt;- function(N, beta, p = 0.5, sigma_x = 1, sigma_e = 1) {
  # N: number of observations
  # beta: effect of treatment
  # p: probability of treatment
  # sigma_x, sigma_e: variances of covariates and errors 
  #                   (both independent of the treatment vector)
    
  tibble(treatment = rbinom(N, 1, p),
         covariate = rnorm(N, 0, sigma_x),
         error = rnorm(N, 0, sigma_e),
         # although the errors in logit are logistic, not normal
         # so I should be using rlogis instead of rnorm ^^^^
         outcome = as.integer(beta * treatment + covariate + error &gt; 0))
}

# Create a dataset of parameters,
dfs &lt;- tibble(N = rep(10000, 1000), 
              beta = rep(0.1, 1000)) %&gt;% 
  mutate(true_coefficient = log(pnorm(beta * 1) / (1 - pnorm(beta * 1)))) 

# Then call create_data on each set of parameters to create 1000 independent 
# copies of a dataset (in list-col form)
dfs &lt;- dfs %&gt;% 
  rowwise() %&gt;% 
  mutate(data = list(create_data(N = N, beta = beta))) %&gt;% 
  ungroup()
dfs
## # A tibble: 1,000 x 4
##         N  beta true_coefficient data                 
##     &lt;dbl&gt; &lt;dbl&gt;            &lt;dbl&gt; &lt;list&gt;               
##  1 10000. 0.100            0.160 &lt;tibble [10,000 × 4]&gt;
##  2 10000. 0.100            0.160 &lt;tibble [10,000 × 4]&gt;
##  3 10000. 0.100            0.160 &lt;tibble [10,000 × 4]&gt;
##  4 10000. 0.100            0.160 &lt;tibble [10,000 × 4]&gt;
##  5 10000. 0.100            0.160 &lt;tibble [10,000 × 4]&gt;
##  6 10000. 0.100            0.160 &lt;tibble [10,000 × 4]&gt;
##  7 10000. 0.100            0.160 &lt;tibble [10,000 × 4]&gt;
##  8 10000. 0.100            0.160 &lt;tibble [10,000 × 4]&gt;
##  9 10000. 0.100            0.160 &lt;tibble [10,000 × 4]&gt;
## 10 10000. 0.100            0.160 &lt;tibble [10,000 × 4]&gt;
## # ... with 990 more rows</code></pre>
</div>
<div id="use-logit-to-estimate-treatment-effect" class="section level2">
<h2>Use logit to estimate treatment effect</h2>
<p>Next, we want to estimate the treatment effect for each dataset. I use <code>glm</code> to estimate a logit model (since the outcome is binary), with two specifications: in one, I only include the <code>treatment</code>, and in the other, I include the <code>treatment</code> and the <code>covariate</code>.</p>
<pre class="r"><code># A function to estimate the two models, save the estimates and return them in a tibble
# to go in another list-col in our original tibble
get_estimates &lt;- function(data) {
  # estimate base model, treatment only, no covariates
  base &lt;- glm(outcome ~ treatment, family = binomial(link = &quot;logit&quot;), data = data)
  # estimate covariate model, including treatment and covariate
  covariate &lt;- glm(outcome ~ treatment + covariate, family = binomial(link = &quot;logit&quot;), data = data)
  # put them together and broom::tidy and bind_rows() the results
  list(base = base, 
       covariate = covariate) %&gt;% 
    map(tidy) %&gt;% 
    bind_rows(.id = &quot;model&quot;) %&gt;%
    filter(term == &quot;treatment&quot;)
}</code></pre>
<p>Then we estimate the models for all the datasets:</p>
<pre class="r"><code>dfs_estimates &lt;- dfs %&gt;% 
  rownames_to_column(&quot;id&quot;) %&gt;% 
  mutate(estimates = map(data, get_estimates)) %&gt;% 
  unnest(estimates)
dfs_estimates
## # A tibble: 2,000 x 10
##    id         N  beta true_coefficient model    term    estimate std.error
##    &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;            &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;
##  1 1     10000. 0.100            0.160 base     treatm…   0.150     0.0401
##  2 1     10000. 0.100            0.160 covaria… treatm…   0.221     0.0494
##  3 2     10000. 0.100            0.160 base     treatm…   0.0730    0.0400
##  4 2     10000. 0.100            0.160 covaria… treatm…   0.117     0.0486
##  5 3     10000. 0.100            0.160 base     treatm…   0.123     0.0400
##  6 3     10000. 0.100            0.160 covaria… treatm…   0.166     0.0490
##  7 4     10000. 0.100            0.160 base     treatm…   0.127     0.0400
##  8 4     10000. 0.100            0.160 covaria… treatm…   0.186     0.0494
##  9 5     10000. 0.100            0.160 base     treatm…   0.104     0.0400
## 10 5     10000. 0.100            0.160 covaria… treatm…   0.183     0.0492
## # ... with 1,990 more rows, and 2 more variables: statistic &lt;dbl&gt;,
## #   p.value &lt;dbl&gt;</code></pre>
<p>Done and done.</p>
</div>
<div id="plot-1000-estimates" class="section level2">
<h2>Plot 1000 estimates</h2>
<pre class="r"><code>dfs_estimates %&gt;% 
  ggplot(aes(x = estimate, fill = model)) +
  geom_density(alpha = 0.65) + 
  geom_vline(xintercept = unique(dfs$true_coefficient), 
             colour = viridis_pal(option = &quot;E&quot;)(1)) +
  scale_fill_viridis(option = &quot;E&quot;, discrete = TRUE) +
  scale_x_continuous(breaks = c(0, 0.1, 0.16, 0.2, 0.3)) +
  theme_minimal() +
  labs(x = &quot;Estimate&quot;, y = &quot;Density&quot;, 
       title = &quot;Including uncorrelated covariate reduces attenuation bias in logistic model&quot;,
       subtitle = &quot;True coefficient shown as vertical line at 0.16&quot;) </code></pre>
<p><img src="/post/2018-02-19-why-bother-with-covariates-if-treatment-is-randomly-assigned_files/figure-html/unnamed-chunk-4-1.png" width="768" /></p>
<p>Whoops! Logit models don’t work the same way as OLS! Logit suffers from attenuation bias if you don’t include covariates, <em>even if the treatment is randomly assigned</em>. See some explanations here <a href="https://stats.stackexchange.com/questions/113766/omitted-variable-bias-in-logistic-regression-vs-omitted-variable-bias-in-ordina">on stats.stackexchange.com</a> and <a href="https://academic.oup.com/esr/article-abstract/26/1/67/540767?redirectedFrom=PDF">a paper</a> and <a href="http://www.cannectin.ca/workfiles/Nov%2013.09-Slides.pdf">its slides</a>. The funny thing is, these are sociology papers and for the life of me I can’t remember anyone mentioning this in my econometrics courses. Maybe because we focus so much on getting OLS and its variants (IV, etc.) correct that I didn’t notice.</p>
<p>Well dang. Now there are two moving parts when we add uncorrelated covariates: (1) including covariates should reduce standard errors of the residuals, which should reduce the standard errors of the coefficients; and (2) including covariates actually corrects for attenuation bias, which directly affects the coefficient estimate itself. Let’s take a closer look at the estimates, standard errors and p-values.</p>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<pre class="r"><code>dfs_estimates %&gt;%
  select(id, model, estimate, std.error, p.value) %&gt;% 
  gather(key = type, value = value, -(id:model)) %&gt;% 
  ggplot(aes(x = model, y = value, group = model)) + 
  geom_boxplot() +
  expand_limits(y = 0) + 
  facet_wrap(~ type, scales = &quot;free&quot;) + 
  labs(x = &quot;Model&quot;, y = &quot;&quot;, 
       title = &quot;p-values are lower for covariate model because it corrects for\nattenuation bias, not because covariates reduce standard errors.&quot;)</code></pre>
<p><img src="/post/2018-02-19-why-bother-with-covariates-if-treatment-is-randomly-assigned_files/figure-html/unnamed-chunk-5-1.png" width="768" /></p>
<p>This boxplot shows that p-values are lower in the covariate model because the estimates are corrected by attenuation bias; in other words, they’re farther away from zero (in this case, they’re higher because the true effect is positive). The standard errors are actually <strong>higher</strong> in the covariate model, which I didn’t expect. If this were OLS, the standard errors would typically (but not always) be smaller, especially as the sample size gets larger.</p>
<p>Next up, I should replicate the CUPED post to look at power and sample size.</p>
</div>
